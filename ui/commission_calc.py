"""
Commission Calculation UI Module
Handles all commission calculation logic and display
"""
import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Dict, List, Tuple, Optional
from .utils import (
    safe_session_get,
    safe_session_check,
    safe_session_init,
    format_currency,
    format_percentage,
    show_progress,
    get_revenue_column,
    get_safe_revenue_data,
    get_current_pay_period,
    get_selected_pay_period,
    format_pay_period,
    is_pay_period_configured,
    get_employee_hours_with_overrides,
    batch_process_large_dataset,
    cached_commission_calculation,
    optimize_dataframe_memory
)
from .config import get_config, optimize_for_data_size

def display_commission_calculate():
    """Main commission calculation interface"""
    st.markdown("### 🧮 Calculate Commissions")
    
    # Check if pay periods are configured
    if not is_pay_period_configured():
        st.error("❌ Pay periods are not configured. Please go to Company Setup → Pay Period Setup to configure your pay schedule.")
        return
    
    # Check data availability
    has_employee_data = safe_session_check('employee_data') and len(safe_session_get('employee_data', pd.DataFrame())) > 0
    has_timesheet_data = safe_session_get('saved_timesheet_data') is not None
    
    # Check for lead generation data in revenue data
    has_lead_data = False
    revenue_data = safe_session_get('saved_revenue_data')
    if revenue_data is not None and not revenue_data.empty:
        # Check if there's a "Lead Generated By" column
        lead_columns = [col for col in revenue_data.columns if 'lead' in col.lower() and 'by' in col.lower()]
        if lead_columns:
            lead_col = lead_columns[0]
            has_lead_data = revenue_data[lead_col].notna().any() and (revenue_data[lead_col] != '').any()
    
    if not has_employee_data:
        st.warning("⚠️ No employee data found. Please set up employees first.")
        return
    
    # Pay Period Selection
    st.markdown("#### 📅 Select Pay Period for Calculation")
    
    pay_periods = safe_session_get('pay_periods', [])
    if not pay_periods:
        st.error("❌ No pay periods available. Please check your pay period configuration.")
        return
    
    # Create pay period selector
    current_period = get_current_pay_period()
    period_options = [format_pay_period(p) for p in pay_periods]
    
    # Default to current pay period if available
    default_index = current_period['number'] - 1 if current_period else 0
    
    selected_period_idx = st.selectbox(
        "Pay Period",
        range(len(period_options)),
        format_func=lambda x: period_options[x],
        index=default_index,
        help="Select the pay period to calculate commissions for"
    )
    
    selected_period = pay_periods[selected_period_idx]
    
    # Display selected period details
    col1, col2, col3 = st.columns(3)
    with col1:
        st.info(f"**Period Start:** {selected_period['start_date'].strftime('%B %d, %Y')}")
    with col2:
        st.info(f"**Period End:** {selected_period['end_date'].strftime('%B %d, %Y')}")
    with col3:
        st.info(f"**Pay Date:** {selected_period['pay_date'].strftime('%B %d, %Y')}")
    
    # Data availability info
    st.markdown("#### 📊 Available Data Sources")
    display_data_availability(has_timesheet_data, has_lead_data, revenue_data is not None)
    
    # Employee selection
    st.markdown("#### 👥 Select Employees")
    employee_data = safe_session_get('employee_data', pd.DataFrame())
    
    if not employee_data.empty:
        employee_names = employee_data['Name'].tolist()
        selected_employees = st.multiselect(
            "Employees to Calculate",
            employee_names,
            default=employee_names
        )
    else:
        st.error("No employees found in the system")
        return
    
    # Calculate button
    if st.button("🧮 Calculate Commissions", type="primary", use_container_width=True):
        if not selected_employees:
            st.error("❌ Please select at least one employee")
            return
        
        # Perform commission calculation for the selected pay period
        calculate_all_commissions(selected_employees, selected_period['start_date'], selected_period['end_date'])

def display_data_availability(has_timesheet: bool, has_lead: bool, has_revenue: bool):
    """Display data availability status"""
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if has_timesheet:
            st.success("⏰ Timesheet Data - ✅ Available")
        else:
            st.info("⏰ Timesheet Data - ⚠️ Not loaded")
    
    with col2:
        if has_lead:
            st.success("🎯 Lead Generation - ✅ Available")
        else:
            st.info("🎯 Lead Generation - ⚠️ Not found")
    
    with col3:
        if has_revenue:
            st.success("💰 Revenue Data - ✅ Available")
        else:
            st.info("💰 Revenue Data - ⚠️ Not loaded")

def calculate_all_commissions(selected_employees: List[str], start_date, end_date):
    """Calculate all types of commissions for selected employees with optimization"""
    
    # Initialize results container
    commission_results = []
    
    # Get necessary data
    employee_data = safe_session_get('employee_data', pd.DataFrame())
    revenue_data = safe_session_get('saved_revenue_data')
    timesheet_data = safe_session_get('saved_timesheet_data')
    business_unit_settings = safe_session_get('business_unit_commission_settings', {})
    
    # Check if we have any data to calculate
    if revenue_data is None and timesheet_data is None:
        st.error("❌ No data available for commission calculation. Please upload revenue or timesheet data.")
        return
    
    # Get configuration and optimize for data size
    config = get_config()
    data_size = len(revenue_data) if revenue_data is not None else 0
    optimization_settings = optimize_for_data_size(data_size)
    
    # Optimize DataFrames for memory if enabled
    if optimization_settings.get('memory_optimization', False):
        if revenue_data is not None:
            revenue_data = optimize_dataframe_memory(revenue_data)
        if timesheet_data is not None:
            timesheet_data = optimize_dataframe_memory(timesheet_data)
        if not employee_data.empty:
            employee_data = optimize_dataframe_memory(employee_data)
    
    # Create progress bar only for large datasets
    if optimization_settings.get('progress_updates', False):
        progress_bar = st.progress(0)
        status_text = st.empty()
    else:
        progress_bar = None
        status_text = None
    
    # Calculate revenue-based commissions
    if revenue_data is not None:
        if status_text:
            status_text.text("Calculating revenue-based commissions...")
        
        # Use cached calculation for better performance
        if optimization_settings.get('enable_caching', True):
            try:
                revenue_commissions = cached_commission_calculation(
                    revenue_data, 
                    business_unit_settings,
                    selected_employees,
                    start_date,
                    end_date
                )
            except Exception:
                # Fallback to regular calculation
                revenue_commissions = calculate_revenue_commissions(
                    revenue_data, 
                    selected_employees, 
                    business_unit_settings,
                    start_date,
                    end_date
                )
        else:
            revenue_commissions = calculate_revenue_commissions(
                revenue_data, 
                selected_employees, 
                business_unit_settings,
                start_date,
                end_date
            )
        
        commission_results.append(revenue_commissions)
        if progress_bar:
            progress_bar.progress(0.5)
    
    # Calculate efficiency pay if timesheet data exists
    if timesheet_data is not None:
        if status_text:
            status_text.text("Calculating efficiency pay...")
        
        # Use batch processing for large datasets
        if optimization_settings.get('batch_size', 0) > 0 and len(selected_employees) > optimization_settings['batch_size']:
            def process_employee_batch(employee_batch):
                return calculate_efficiency_pay(
                    employee_batch,
                    timesheet_data,
                    revenue_commissions if revenue_data is not None else pd.DataFrame(),
                    employee_data
                )
            
            # Process employees in batches
            employee_batches = [selected_employees[i:i + optimization_settings['batch_size']] 
                              for i in range(0, len(selected_employees), optimization_settings['batch_size'])]
            
            batch_results = []
            for batch in employee_batches:
                batch_result = process_employee_batch(batch)
                if not batch_result.empty:
                    batch_results.append(batch_result)
            
            if batch_results:
                efficiency_results = pd.concat(batch_results, ignore_index=True)
            else:
                efficiency_results = pd.DataFrame()
        else:
            efficiency_results = calculate_efficiency_pay(
                selected_employees,
                timesheet_data,
                revenue_commissions if revenue_data is not None else pd.DataFrame(),
                employee_data
            )
        
        commission_results.append(efficiency_results)
        if progress_bar:
            progress_bar.progress(1.0)
    
    # Clear progress indicators
    if progress_bar:
        progress_bar.empty()
    if status_text:
        status_text.empty()
    
    # Display results
    display_commission_results(commission_results, selected_employees)

def calculate_revenue_commissions(revenue_df: pd.DataFrame, selected_employees: List[str], 
                                 business_unit_settings: Dict, start_date, end_date) -> pd.DataFrame:
    """Calculate revenue-based commissions"""
    
    # Filter revenue data by date if date column exists
    if 'Date' in revenue_df.columns:
        try:
            revenue_df['Date'] = pd.to_datetime(revenue_df['Date'])
            mask = (revenue_df['Date'] >= pd.to_datetime(start_date)) & (revenue_df['Date'] <= pd.to_datetime(end_date))
            revenue_df = revenue_df[mask]
        except Exception:
            pass  # If date filtering fails, use all data
    
    # Detect revenue column
    revenue_column = get_revenue_column(revenue_df)
    if not revenue_column:
        st.error("❌ No revenue column found in data")
        return pd.DataFrame()
    
    # Initialize results
    results = []
    
    # Get employee commission overrides if they exist
    employee_overrides = safe_session_get('employee_commission_overrides', {})
    
    # Process each business unit
    for business_unit, settings in business_unit_settings.items():
        if not settings.get('enabled', True):
            continue
        
        # Filter revenue for this business unit
        unit_revenue = revenue_df[revenue_df['Business Unit'] == business_unit] if 'Business Unit' in revenue_df.columns else revenue_df
        
        if unit_revenue.empty:
            continue
        
        # Process Lead Generation commissions
        if 'Lead Generated By' in unit_revenue.columns and settings.get('lead_gen_rate', 0) > 0:
            for _, row in unit_revenue.iterrows():
                lead_gen = row.get('Lead Generated By')
                if pd.notna(lead_gen) and lead_gen in selected_employees:
                    revenue = pd.to_numeric(row.get(revenue_column, 0), errors='coerce')
                    
                    # Check for employee-specific rate override
                    rate = get_employee_commission_rate(
                        lead_gen, business_unit, 'lead_gen', 
                        settings['lead_gen_rate'], employee_overrides
                    )
                    
                    commission = revenue * (rate / 100)
                    
                    results.append({
                        'Employee': lead_gen,
                        'Type': 'Lead Generation',
                        'Business Unit': business_unit,
                        'Revenue': revenue,
                        'Rate': rate,
                        'Commission': commission,
                        'Job': row.get('Job Number', 'Unknown')
                    })
        
        # Process Sales commissions
        if 'Sold By' in unit_revenue.columns and settings.get('sold_by_rate', 0) > 0:
            for _, row in unit_revenue.iterrows():
                sold_by = row.get('Sold By')
                if pd.notna(sold_by) and sold_by in selected_employees:
                    revenue = pd.to_numeric(row.get(revenue_column, 0), errors='coerce')
                    
                    # Check for employee-specific rate override
                    rate = get_employee_commission_rate(
                        sold_by, business_unit, 'sold_by', 
                        settings['sold_by_rate'], employee_overrides
                    )
                    
                    commission = revenue * (rate / 100)
                    
                    results.append({
                        'Employee': sold_by,
                        'Type': 'Sales',
                        'Business Unit': business_unit,
                        'Revenue': revenue,
                        'Rate': rate,
                        'Commission': commission,
                        'Job': row.get('Job Number', 'Unknown')
                    })
        
        # Process Work Done commissions
        if 'Assigned Technicians' in unit_revenue.columns and settings.get('work_done_rate', 0) > 0:
            for _, row in unit_revenue.iterrows():
                techs_str = row.get('Assigned Technicians')
                if pd.notna(techs_str):
                    # Split technicians
                    technicians = [t.strip() for t in str(techs_str).replace('&', ',').split(',') if t.strip()]
                    eligible_techs = [t for t in technicians if t in selected_employees]
                    
                    if eligible_techs:
                        revenue = pd.to_numeric(row.get(revenue_column, 0), errors='coerce')
                        
                        # Calculate commission for each technician
                        for tech in eligible_techs:
                            # Check for employee-specific rate override
                            rate = get_employee_commission_rate(
                                tech, business_unit, 'work_done', 
                                settings['work_done_rate'], employee_overrides
                            )
                            
                            # Each technician gets their rate applied to the full revenue
                            commission = revenue * (rate / 100)
                            
                            results.append({
                                'Employee': tech,
                                'Type': 'Work Done',
                                'Business Unit': business_unit,
                                'Revenue': revenue,
                                'Rate': rate,
                                'Commission': commission,
                                'Job': row.get('Job Number', 'Unknown'),
                                'Technicians': len(eligible_techs)
                            })
    
    return pd.DataFrame(results)

def get_employee_commission_rate(employee: str, business_unit: str, commission_type: str, 
                                default_rate: float, overrides: Dict) -> float:
    """Get commission rate for an employee, checking for overrides"""
    
    # Map commission types to override keys
    type_map = {
        'lead_gen': 'lead_gen_rate',
        'sold_by': 'sold_by_rate', 
        'work_done': 'work_done_rate'
    }
    
    override_key = type_map.get(commission_type)
    use_override_key = f"use_{commission_type}_override"
    
    # Check if there's an override for this employee in this business unit
    if (business_unit in overrides and 
        employee in overrides[business_unit] and
        overrides[business_unit][employee].get(use_override_key, False)):
        
        return overrides[business_unit][employee].get(override_key, default_rate)
    
    return default_rate


def calculate_employee_pay(employee_name: str, regular_hours: float, ot_hours: float, 
                          dt_hours: float, hourly_rate: float, commission_total: float, 
                          commission_plan: str) -> Dict:
    """Calculate employee pay based on their commission plan"""
    
    # Calculate hourly pay with proper multipliers
    regular_pay = regular_hours * hourly_rate
    ot_pay = ot_hours * hourly_rate * 1.5
    dt_pay = dt_hours * hourly_rate * 2.0
    hourly_pay = regular_pay + ot_pay + dt_pay
    
    total_hours = regular_hours + ot_hours + dt_hours
    
    if commission_plan == 'Efficiency Pay':
        # Efficiency pay: max(hourly, commission)
        final_pay = max(hourly_pay, commission_total)
        efficiency_pay = final_pay - hourly_pay  # Can be negative
        
        return {
            'Employee': employee_name,
            'Plan': commission_plan,
            'Regular Hours': regular_hours,
            'OT Hours': ot_hours,
            'DT Hours': dt_hours,
            'Total Hours': total_hours,
            'Hourly Rate': hourly_rate,
            'Regular Pay': regular_pay,
            'OT Pay': ot_pay,
            'DT Pay': dt_pay,
            'Hourly Pay': hourly_pay,
            'Commission Total': commission_total,
            'Efficiency Pay': efficiency_pay,
            'Final Pay': final_pay
        }
    else:  # Hourly + Commission
        final_pay = hourly_pay + commission_total
        
        return {
            'Employee': employee_name,
            'Plan': commission_plan,
            'Regular Hours': regular_hours,
            'OT Hours': ot_hours,
            'DT Hours': dt_hours,
            'Total Hours': total_hours,
            'Hourly Rate': hourly_rate,
            'Regular Pay': regular_pay,
            'OT Pay': ot_pay,
            'DT Pay': dt_pay,
            'Hourly Pay': hourly_pay,
            'Commission Total': commission_total,
            'Efficiency Pay': 0,
            'Final Pay': final_pay
        }

def calculate_efficiency_pay(selected_employees: List[str], timesheet_data: pd.DataFrame,
                           revenue_commissions: pd.DataFrame, employee_data: pd.DataFrame) -> pd.DataFrame:
    """Calculate efficiency pay for employees"""
    
    results = []
    
    for employee in selected_employees:
        # Get employee details
        emp_row = employee_data[employee_data['Name'] == employee]
        
        if emp_row.empty:
            continue
        
        emp_info = emp_row.iloc[0]
        hourly_rate = float(emp_info.get('Hourly Rate', 0))
        commission_plan = emp_info.get('Commission Plan', 'Hourly + Commission')
        
        # Get hours (with overrides)
        regular_hours, ot_hours, dt_hours = get_employee_hours_with_overrides(employee, timesheet_data)
        
        # Get commission total for this employee
        if not revenue_commissions.empty and 'Employee' in revenue_commissions.columns:
            emp_commissions = revenue_commissions[revenue_commissions['Employee'] == employee]
            commission_total = emp_commissions['Commission'].sum() if not emp_commissions.empty else 0
        else:
            commission_total = 0
        
        # Calculate pay based on plan
        pay_details = calculate_employee_pay(
            employee, regular_hours, ot_hours, dt_hours,
            hourly_rate, commission_total, commission_plan
        )
        
        results.append(pay_details)
    
    return pd.DataFrame(results)

def display_commission_results(commission_results: List[pd.DataFrame], selected_employees: List[str]):
    """Display commission calculation results"""
    
    st.markdown("---")
    st.markdown("### 📊 Commission Calculation Results")
    
    # Combine all results
    all_results = pd.DataFrame()
    for df in commission_results:
        if not df.empty:
            all_results = pd.concat([all_results, df], ignore_index=True)
    
    if all_results.empty:
        st.warning("No commission data found for the selected period and employees.")
        return
    
    # Create tabs for different views
    tab1, tab2, tab3, tab4 = st.tabs([
        "💰 Commission Summary",
        "📋 Detailed Breakdown", 
        "💸 Efficiency Pay Analysis",
        "📊 Export Results"
    ])
    
    with tab1:
        display_commission_summary(all_results, selected_employees)
    
    with tab2:
        display_detailed_breakdown(all_results)
    
    with tab3:
        display_efficiency_pay_analysis(all_results)
    
    with tab4:
        export_commission_results(all_results)

def display_commission_summary(results: pd.DataFrame, selected_employees: List[str]):
    """Display commission summary"""
    
    st.markdown("#### 💰 Commission Summary by Employee")
    
    # Get revenue commissions
    revenue_results = results[results.get('Type').notna()] if 'Type' in results.columns else pd.DataFrame()
    
    # Get efficiency pay results
    efficiency_results = results[results.get('Plan').notna()] if 'Plan' in results.columns else pd.DataFrame()
    
    # Create summary for each employee
    summary_data = []
    
    for employee in selected_employees:
        emp_summary = {'Employee': employee}
        
        # Revenue commissions
        if not revenue_results.empty:
            emp_revenue = revenue_results[revenue_results['Employee'] == employee]
            
            # Sum by type
            lead_gen = emp_revenue[emp_revenue['Type'] == 'Lead Generation']['Commission'].sum()
            sales = emp_revenue[emp_revenue['Type'] == 'Sales']['Commission'].sum()
            work_done = emp_revenue[emp_revenue['Type'] == 'Work Done']['Commission'].sum()
            
            emp_summary['Lead Gen Commission'] = lead_gen
            emp_summary['Sales Commission'] = sales
            emp_summary['Work Done Commission'] = work_done
            emp_summary['Total Commission'] = lead_gen + sales + work_done
        else:
            emp_summary['Total Commission'] = 0
        
        # Efficiency pay
        if not efficiency_results.empty:
            emp_efficiency = efficiency_results[efficiency_results['Employee'] == employee]
            if not emp_efficiency.empty:
                emp_data = emp_efficiency.iloc[0]
                emp_summary['Commission Plan'] = emp_data.get('Plan', 'Unknown')
                emp_summary['Hourly Pay'] = emp_data.get('Hourly Pay', 0)
                emp_summary['Efficiency Pay'] = emp_data.get('Efficiency Pay', 0)
                emp_summary['Final Pay'] = emp_data.get('Final Pay', 0)
        
        summary_data.append(emp_summary)
    
    summary_df = pd.DataFrame(summary_data)
    
    # Format currency columns
    currency_cols = ['Lead Gen Commission', 'Sales Commission', 'Work Done Commission', 
                    'Total Commission', 'Hourly Pay', 'Efficiency Pay', 'Final Pay']
    
    for col in currency_cols:
        if col in summary_df.columns:
            summary_df[col] = summary_df[col].apply(lambda x: format_currency(x) if pd.notna(x) else '$0.00')
    
    # Display summary table
    st.dataframe(summary_df, use_container_width=True, hide_index=True)
    
    # Show totals
    st.markdown("---")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_commission = revenue_results['Commission'].sum() if not revenue_results.empty else 0
        st.metric("Total Commissions", format_currency(total_commission))
    
    with col2:
        total_hourly = efficiency_results['Hourly Pay'].sum() if not efficiency_results.empty and 'Hourly Pay' in efficiency_results.columns else 0
        st.metric("Total Hourly Pay", format_currency(total_hourly))
    
    with col3:
        total_efficiency = efficiency_results['Efficiency Pay'].sum() if not efficiency_results.empty and 'Efficiency Pay' in efficiency_results.columns else 0
        st.metric("Total Efficiency Pay", format_currency(total_efficiency))
    
    with col4:
        total_final = efficiency_results['Final Pay'].sum() if not efficiency_results.empty and 'Final Pay' in efficiency_results.columns else 0
        st.metric("Total Final Pay", format_currency(total_final))

def display_detailed_breakdown(results: pd.DataFrame):
    """Display detailed commission breakdown"""
    
    st.markdown("#### 📋 Detailed Commission Breakdown")
    
    # Revenue commissions
    revenue_results = results[results.get('Type').notna()] if 'Type' in results.columns else pd.DataFrame()
    
    if not revenue_results.empty:
        st.markdown("##### Revenue-Based Commissions")
        
        # Format for display
        display_df = revenue_results.copy()
        display_df['Revenue'] = display_df['Revenue'].apply(format_currency)
        display_df['Commission'] = display_df['Commission'].apply(format_currency)
        display_df['Rate'] = display_df['Rate'].apply(lambda x: format_percentage(x))
        
        # Reorder columns
        column_order = ['Employee', 'Type', 'Business Unit', 'Job', 'Revenue', 'Rate', 'Commission']
        display_df = display_df[[col for col in column_order if col in display_df.columns]]
        
        st.dataframe(display_df, use_container_width=True, hide_index=True)

def display_efficiency_pay_analysis(results: pd.DataFrame):
    """Display efficiency pay analysis"""
    
    st.markdown("#### 💸 Efficiency Pay Analysis")
    
    # Get efficiency pay results
    efficiency_results = results[results.get('Plan').notna()] if 'Plan' in results.columns else pd.DataFrame()
    
    if efficiency_results.empty:
        st.info("No efficiency pay data available")
        return
    
    # Format for display
    display_df = efficiency_results.copy()
    
    # Format currency columns
    currency_cols = ['Hourly Rate', 'Regular Pay', 'OT Pay', 'DT Pay', 'Hourly Pay', 
                    'Commission Total', 'Efficiency Pay', 'Final Pay']
    
    for col in currency_cols:
        if col in display_df.columns:
            display_df[col] = display_df[col].apply(format_currency)
    
    # Format hour columns
    hour_cols = ['Regular Hours', 'OT Hours', 'DT Hours', 'Total Hours']
    for col in hour_cols:
        if col in display_df.columns:
            display_df[col] = display_df[col].apply(lambda x: f"{x:.2f}")
    
    st.dataframe(display_df, use_container_width=True, hide_index=True)
    
    # Show efficiency pay statistics
    st.markdown("##### Efficiency Pay Impact")
    
    efficiency_employees = efficiency_results[efficiency_results['Plan'] == 'Efficiency Pay']
    
    if not efficiency_employees.empty:
        col1, col2, col3 = st.columns(3)
        
        with col1:
            positive_efficiency = len(efficiency_employees[efficiency_employees['Efficiency Pay'] > 0])
            st.metric("Employees with Positive Efficiency", positive_efficiency)
        
        with col2:
            negative_efficiency = len(efficiency_employees[efficiency_employees['Efficiency Pay'] < 0])
            st.metric("Employees with Negative Efficiency", negative_efficiency)
        
        with col3:
            avg_efficiency = efficiency_employees['Efficiency Pay'].mean()
            st.metric("Average Efficiency Pay", format_currency(avg_efficiency))

def export_commission_results(results: pd.DataFrame):
    """Export commission results"""
    
    st.markdown("#### 📊 Export Commission Results")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # CSV export
        csv = results.to_csv(index=False)
        st.download_button(
            label="📄 Download as CSV",
            data=csv,
            file_name=f"commission_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv",
            use_container_width=True
        )
    
    with col2:
        # Excel export
        from io import BytesIO
        output = BytesIO()
        
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # Summary sheet
            summary_df = create_commission_summary_for_export(results)
            summary_df.to_excel(writer, sheet_name='Summary', index=False)
            
            # Detailed results
            results.to_excel(writer, sheet_name='Detailed Results', index=False)
        
        excel_data = output.getvalue()
        
        st.download_button(
            label="📊 Download as Excel",
            data=excel_data,
            file_name=f"commission_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            use_container_width=True
        )

def create_commission_summary_for_export(results: pd.DataFrame) -> pd.DataFrame:
    """Create a summary DataFrame for export"""
    
    # This would aggregate the results by employee
    # Similar to display_commission_summary but returns raw data
    return results.groupby('Employee').agg({
        'Commission': 'sum',
        'Revenue': 'sum'
    }).reset_index() if 'Commission' in results.columns else pd.DataFrame()